<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>this 바이딩</title>
    <link rel="stylesheet" href="/src/css/study.css">

</head>
<body>
    <h1>this와 this 바이딩</h1>
    <section>
        <h2>this란?</h2>
        <ul>
            <li><code>this</code>는 객체 내부에서 자기 자신(해당 객체)을 가리키는 키워드</li>
            <li>즉, 객체의 속성과 메서드를 참조할 수 있게 해줌</li>
            <li>함수(function)가 어디에 선언되었는지가 아니라, "누가 호출했는지(실행 주체)"에 따라 바인딩됨</li>
            <li>이를 문제라 여겨 위치로 this를 참조(캡처)하는 화살표함수(()=>{})가 등장함(화살표 함수는 바인딩이 안됨)</li>
        </ul>
    </section>

    <section>
        <h2>1. 전역에서의 this</h2>
        <p>script 는 브라우저에 의해 실행되고 있기 때문에 전역에서 this는 브라우저인 window 입니다. </p>
        <pre>
console.log(this);
// window 객체 (브라우저 환경)
  </pre>
    </section>

    <section>
        <h2>2. 함수에서의 this</h2>
        <p>this는 함수를 실행하는 객체를 의미합니다. 때문에 전역에서 실행되는 함수는 this를 window로 사용(binding)합니다. </p>

        <pre>
function show() {
  console.log(this);
}
show();
// window (브라우저에서 일반 함수 호출 시 전역 객체에 바인딩)
  </pre>
    </section>

    <section>
        <h2>3. 객체 메서드에서의 this</h2>
        <p> sayHi 는 user 가 실행하기 때문에 this는 user 입니다.</p>
        <pre>
const user = {
  name: "경민",
  sayHi: function() {
    console.log(this.name);
  }
};

user.sayHi(); // "경민"
  </pre>
        <ul>
            <li>객체 내부 메서드에서 <code>this</code>는 해당 객체(user)를 가리킴</li>
            <li>즉, <strong>실행 주체인 객체에 바인딩</strong></li>
        </ul>
    </section>

    <section>
        <h2>4. 함수 참조와 바인딩</h2>
        <p>sayHi 가 user의 필드로 존재하는 함수지만 실행 주체가 바뀌면 this도 바뀝니다.</p>
        <pre>
const user = {
  name: "경민",
  sayHi: function() {
    console.log("안녕,", this.name);
  }
};

// 함수를 다른 변수에 저장
const hi = user.sayHi;
hi();
// "안녕, undefined"
// 실행 주체가 없으므로 this는 window에 바인딩됨
  </pre>
        <ul>
            <li>함수 자체를 꺼내 호출하면 실행 주체 객체가 사라지므로 this가 의도치 않게 전역(window)에 바인딩됨</li>
        </ul>
    </section>

    <section>
        <h2>5. 의도치 않은 바인딩 예시</h2>
        <h3>함수를 실행하는 객체가 바뀐 경우</h3>
        <p>함수 내부의 this를 객체의 필드 참조로 오해하지 마세요. this는 실행하는 객체입니다.</p>
        <pre>
const user = {
  name: "경민",
  sayHi: function() {
    console.log("안녕,", this.name);
  }
};

// 다른 변수에 함수만 저장
const hi = user.sayHi;

hi();
// "안녕, undefined"
// 실행 주체 객체(user)가 사라져서 this는 window에 바인딩됨
  </pre>
        <ul>
            <li>메서드를 객체에서 분리해 변수로 호출하면 <code>this</code>는 더 이상 원래 객체를 가리키지 않음</li>
            <li>즉, 실행 주체가 달라지면서 의도하지 않게 전역(window)에 바인딩됨</li>
        </ul>

        <h3>내부적으로 다른 객체가 함수를 실행하는 경우</h3>
        <pre>
const user = {
  name: "경민",
  sayHi: function() {
    setTimeout(function(){
            console.log("안녕,", this.name);
            }, 1000);
  };
};
    user.sayHi();
    // 1초 뒤: "안녕, undefined"
    // (setTimeout이 호출 주체가 되어서 this가 window에 바인딩)
  </pre>
    </section>

    <section>
        <h2>6. this 바인딩 제어 (call / bind)</h2>
        <pre>
const user = { name: "경민" };

function greet() {
  console.log("Hello,", this.name);
}

greet.call(user);  // Hello, 경민
const bound = greet.bind(user);
bound();           // Hello, 경민
  </pre>
        <ul>
            <li><code>call</code>: 즉시 실행하면서 this 지정</li>
            <li><code>bind</code>: 새로운 함수를 만들어 this를 고정</li>
        </ul>
    </section>
    <section>
        <h2>7. 화살표 함수와 this</h2>
        <p>
            화살표 함수는 독립적인 this를 만들지 않고, 자신을 감싸는
            <strong>가장 가까운 function 함수나 class 생성자의 this</strong>를 그대로 캡처한다.
        </p>

        <h3>1) 객체 메서드로 직접 쓰면 안되는 예</h3>
        <ul>
            <li>객체 메서드를 화살표 함수로 정의하면 실행 주체 객체에 바인딩되지 않음</li>
            <li>this는 전역(window) 또는 상위 스코프 this를 가리키게 됨</li>
        </ul>
        <pre>
const user = {
  name: "경민",
  // 잘못된 패턴: 메서드를 화살표로 정의
  sayHi: () => {
    console.log("안녕,", this.name);
  }
};
user.sayHi();
// "안녕, undefined"
// user가 아닌 전역(this)을 참조
</pre>

        <h3>2) 생성자 함수 내부에서의 차이</h3>
        <ul>
            <li>일반 메서드는 실행 주체에 따라 this가 바뀜</li>
            <li>화살표 함수는 생성자 함수(User)의 this(인스턴스)에 고정됨</li>
        </ul>
        <pre>
function User() {
  this.name = "경민";

  this.greeting = function() {
    console.log("Hello,", this.name);
  };

  this.arrowGreeting = () => {
    console.log("Hello,", this.name);
  };
}

let user = new User();

// 실행 주체가 user → 둘 다 정상 동작
user.greeting();      // Hello, 경민
user.arrowGreeting(); // Hello, 경민

// 메서드를 분리해서 실행
let g1 = user.greeting;
g1();                 // Hello, undefined (this → window)

let g2 = user.arrowGreeting;
g2();                 // Hello, 경민 (this가 인스턴스로 고정)
</pre>

        <h3>3) 클래스 내부에서의 사용</h3>
        <ul>
            <li>class 필드에 화살표 함수를 정의하면 인스턴스의 this에 자동으로 바인딩됨</li>
            <li>내부 콜백에서도 this가 흔들리지 않음</li>
        </ul>
        <pre>
class Player {
  constructor(name) {
    this.name = name;
  }
  // 인스턴스 필드 화살표 함수
  shout = () => {
    console.log("플레이어:", this.name);
  }
}

const pl = new Player("영희");
pl.shout();
// "플레이어: 영희"
</pre>

        <h3>4) 비동기/콜백에서 유용</h3>
        <ul>
            <li>일반 함수 콜백은 호출 주체가 바뀌어 this가 의도치 않게 바인딩됨</li>
            <li>화살표 함수는 외부 this를 캡처해 안정적으로 인스턴스 속성을 참조할 수 있음</li>
        </ul>
        <pre>
class Counter {
  constructor() {
    this.count = 0;
  }

  start() {
    // 화살표 함수: Counter 인스턴스의 this를 유지
    this.timerId = setInterval(() => {
      this.count++;
      console.log("count:", this.count);
    }, 1000);
  }

  stop() {
    clearInterval(this.timerId);
  }
}

const c = new Counter();
c.start();
// 1초마다 "count: 1", "count: 2", ...
// this는 항상 Counter 인스턴스
</pre>
    </section>
    <section>
        <h2>this와 화살표 함수 연습 문제 (20문제)</h2>
        <ol>
            <li>브라우저 전역 영역에서 <code>console.log(this)</code>를 실행했을 때 출력되는 객체는 무엇인가?</li>
            <li>아래 코드를 실행했을 때 무엇이 출력되는가?
                <pre>
function show() {
  console.log(this);
}
show();
      </pre>
            </li>
            <li>다음 코드의 실행 결과를 예측하시오.
                <pre>
const user = {
  name: "경민",
  sayHi: function() {
    console.log(this.name);
  }
};
user.sayHi();
      </pre>
            </li>
            <li>아래 코드 실행 결과를 쓰시오.
                <pre>
const user = {
  name: "경민",
  sayHi: function() {
    console.log("안녕,", this.name);
  }
};
const hi = user.sayHi;
hi();
      </pre>
            </li>
            <li>위 코드에서 <code>hi()</code>가 "안녕, undefined"를 출력하는 이유를 설명하시오.</li>
            <li>아래 코드에서 this는 무엇을 가리키는가?
                <pre>
const obj = {
  num: 100,
  inner: {
    num: 200,
    show: function() {
      console.log(this.num);
    }
  }
};
obj.inner.show();
      </pre>
            </li>
            <li>아래 코드의 실행 결과를 예측하시오.
                <pre>
const user = {
  name: "경민",
  show: function() {
    function inner() {
      console.log(this.name);
    }
    inner();
  }
};
user.show();
      </pre>
            </li>
            <li>위 문제에서 <code>inner()</code>가 <code>undefined</code>를 출력하는 이유를 설명하시오.</li>
            <li><code>call</code> 메서드를 사용해 다음 함수를 user 객체에 바인딩하여 실행하시오.
                <pre>
function greet() {
  console.log("Hello,", this.name);
}
const user = { name: "Kim" };
      </pre>
            </li>
            <li><code>apply</code>와 <code>call</code>의 차이점을 설명하시오.</li>
            <li><code>bind</code> 메서드를 사용하여 다음 함수를 user 객체에 고정 바인딩하고 실행하시오.
                <pre>
function greet() {
  console.log("Hello,", this.name);
}
const user = { name: "경민" };
      </pre>
            </li>
            <li>아래 코드의 결과를 예측하시오.
                <pre>
const user = {
  name: "경민",
  say: () => {
    console.log("안녕,", this.name);
  }
};
user.say();
      </pre>
            </li>
            <li>위 코드에서 화살표 함수가 <code>undefined</code>를 출력하는 이유를 설명하시오.</li>
            <li>화살표 함수의 this는 어디에 바인딩되는가?</li>
            <li>아래 코드의 실행 결과를 쓰시오.
                <pre>
function Person(name) {
  this.name = name;
  this.say = () => {
    console.log("안녕,", this.name);
  };
}
const p = new Person("영희");
p.say();
      </pre>
            </li>
            <li>위 문제에서 화살표 함수가 Person 인스턴스의 this를 올바르게 참조할 수 있는 이유를 설명하시오.</li>
            <li>아래 클래스 코드의 실행 결과를 쓰시오.
                <pre>
class Player {
  constructor(name) {
    this.name = name;
  }
  shout = () => {
    console.log("플레이어:", this.name);
  }
}
const pl = new Player("철수");
pl.shout();
      </pre>
            </li>
            <li>비동기 상황에서 화살표 함수가 유용한 이유를 설명하시오. (힌트: setInterval, 이벤트 콜백)</li>
            <li>아래 코드의 실행 결과를 예측하시오.
                <pre>
class Counter {
  constructor() {
    this.count = 0;
  }
  start() {
    setInterval(() => {
      this.count++;
      console.log(this.count);
    }, 1000);
  }
}
const c = new Counter();
c.start();
      </pre>
            </li>
            <li>화살표 함수와 일반 함수의 this 바인딩 차이를 비교 설명하시오.</li>
            <li>
                아래의 코드의 결과를 예상하고 이유를 설명하세요. <br>
                <pre><code>

function User() {
    this.name = "경민";
    this.greeting=function (){
        console.log("Hello,", this.name);
    }
    this.arrowGreeting = () => {
        console.log("Hello,", this.name);
    }
}
let user=new User();
user.arrowGreeting();
user.greeting();


let greeting=user.greeting;
greeting();

let arrowGreeting=user.arrowGreeting;
arrowGreeting();

                </code></pre>
            </li>
        </ol>
    </section>
    <section>
        <h2>this와 화살표 함수 정답/해설</h2>
        <ol>
            <li>
                브라우저 전역 <code>console.log(this)</code> → <strong>window 객체</strong>
            </li>

            <li>
      <pre>
function show() {
  console.log(this);
}
show(); // window
      </pre>
                일반 함수 호출의 this → 전역(window)
            </li>

            <li>
      <pre>
const user = {
  name: "경민",
  sayHi: function() {
    console.log(this.name);
  }
};
user.sayHi(); // "경민"
      </pre>
                메서드 호출 주체가 user → this = user
            </li>

            <li>
      <pre>
const user = {
  name: "경민",
  sayHi: function() {
    console.log("안녕,", this.name);
  }
};
const hi = user.sayHi;
hi(); // "안녕, undefined"
      </pre>
            </li>

            <li>
                설명: 함수 참조를 분리해 호출 → 실행 주체가 없음 → this = window → undefined 출력
            </li>

            <li>
      <pre>
const obj = {
  num: 100,
  inner: {
    num: 200,
    show: function() {
      console.log(this.num);
    }
  }
};
obj.inner.show(); // 200
      </pre>
                실행 주체가 inner → this.num = 200
            </li>

            <li>
      <pre>
const user = {
  name: "경민",
  show: function() {
    function inner() {
      console.log(this.name);
    }
    inner();
  }
};
user.show(); // undefined
      </pre>
                내부 함수 호출은 전역 실행 → this = window
            </li>

            <li>
                설명: 내부 함수는 실행 주체가 없으므로 this가 window. 해결법 → bind/call/apply 또는 화살표 함수 사용
            </li>

            <li>
      <pre>
function greet() {
  console.log("Hello,", this.name);
}
const user = { name: "Kim" };

greet.call(user); // "Hello, Kim"
      </pre>
            </li>

            <li>
                <code>call</code> → 인자 나열, <code>apply</code> → 인자 배열.
                둘 다 첫 번째 인자로 this 지정.
            </li>

            <li>
      <pre>
function greet() {
  console.log("Hello,", this.name);
}
const user = { name: "경민" };

const bound = greet.bind(user);
bound(); // "Hello, 경민"
      </pre>
            </li>

            <li>
      <pre>
const user = {
  name: "경민",
  say: () => {
    console.log("안녕,", this.name);
  }
};
user.say(); // "안녕, undefined"
      </pre>
                화살표 함수의 this는 객체 user가 아니라 상위 스코프(this = window)
            </li>

            <li>
                설명: 화살표 함수는 독립적인 this가 없고, 정의될 당시 상위 스코프의 this를 캡처 → 전역 window
            </li>

            <li>
                화살표 함수의 this = 실행 주체 X, <strong>정의 시점의 가장 가까운 function/class 스코프의 this</strong>
            </li>

            <li>
      <pre>
function User() {
  this.name = "경민";
  this.greeting = function() {
    console.log("Hello,", this.name);
  };
  this.arrowGreeting = () => {
    console.log("Hello,", this.name);
  };
}

let user = new User();

user.greeting();      // Hello, 경민
user.arrowGreeting(); // Hello, 경민

let g1 = user.greeting;
g1();                 // Hello, undefined (this → window)

let g2 = user.arrowGreeting;
g2();                 // Hello, 경민 (this는 인스턴스로 고정)
      </pre>
            </li>

            <li>
                설명: 화살표 함수는 User 생성자 스코프의 this(인스턴스)를 캡처 → 분리 호출해도 인스턴스 유지
            </li>

            <li>
      <pre>
class Player {
  constructor(name) {
    this.name = name;
  }
  shout = () => {
    console.log("플레이어:", this.name);
  }
}

const pl = new Player("철수");
pl.shout(); // "플레이어: 철수"
      </pre>
                class 필드 화살표 함수 → 인스턴스의 this 자동 캡처
            </li>

            <li>
                설명: 비동기 콜백에서 화살표 함수를 쓰면 호출 주체가 달라져도 this가 바뀌지 않고 인스턴스를 유지
            </li>

            <li>
      <pre>
class Counter {
  constructor() {
    this.count = 0;
  }
  start() {
    setInterval(() => {
      this.count++;
      console.log(this.count);
    }, 1000);
  }
}
const c = new Counter();
c.start();
// 1, 2, 3... (this는 Counter 인스턴스)
      </pre>
            </li>

            <li>
                비교 정리:
                <ul>
                    <li>일반 함수: 실행 주체에 따라 this가 달라짐</li>
                    <li>화살표 함수: this 없음 → 정의 시점 상위 function/class의 this 캡처</li>
                    <li>메서드 정의는 일반 함수, 내부 콜백/비동기에는 화살표 함수</li>
                </ul>
            </li>
            <li>
                               <pre><code>

function User() {
    this.name = "경민";
    this.greeting=function (){
        console.log("Hello,", this.name);
    }
    this.arrowGreeting = () => {
        console.log("Hello,", this.name);
    }
}
let user=new User();
user.arrowGreeting(); // Hello 경민
user.greeting(); // Hello 경민


let greeting=user.greeting;
greeting(); // Hello (undefined)

let arrowGreeting=user.arrowGreeting;
arrowGreeting(); // Hello 경민

                </code></pre>
                <ul>
                    <li>function 함수는 함수를 실행하는 객체가 this입니다.</li>
                    <li>()=>{} 함수를 선언할 때 함수를 포함한 Type이 this 입니다.</li>
                </ul>
            </li>
        </ol>
    </section></body>
</html>