<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>자바스크립트의 자료형</title>
    <link rel="stylesheet" href="/src/css/study.css">

</head>
<body>
    <h1>자바스크립트의 자료형(객체)</h1>
    <section>
        <h2>자바스크립트의 자료형</h2>
        <ul>
            <li>자바스크립트 데이터는 크게 <strong>기본형(Primitive)</strong>과 <strong>객체(Object)</strong>로 나눌 수 있다.</li>
        </ul>
        <h3>기본형(Primitive)</h3>
        <ul>
            <li>단일한 값, 더 이상 나눌 수 없음</li>
            <li>불변(Immutable): 한 번 생성된 값은 바뀌지 않음</li>
            <li>종류: number, string, boolean, null, undefined, symbol, bigint</li>
            <li>예: <code>let x = 10; let y = "hello"; let flag = true;</code></li>
        </ul>
        <h3>객체(Object)</h3>
        <ul>
            <li>여러 값을 <strong>키(key)-값(value) 쌍</strong>으로 저장하는 자료형</li>
            <li>변경 가능(Mutable): 안에 들어있는 프로퍼티는 수정/삭제/추가 가능</li>
            <li>배열, 함수, 날짜, 정규식 등도 모두 객체의 한 종류</li>
            <li>예:
                <pre>
let user = {
  name: "경민",
  age: 39,
  isStudent: false
};
      </pre>
            </li>
        </ul>
    </section>
    <section>
        <h2>객체 선언 방법</h2>
        <ul>
            <li><strong>Object 생성자</strong>
                <pre>
let user = new Object();
user.name = "경민";
user.age = 39;
      </pre>
            </li>
            <li><strong>객체 리터럴</strong>
                <pre>
let user = { name: "경민", age: 39 };
      </pre>
            </li>
        </ul>
        <h3>Object와 객체의 관계</h3>
        <ul>
            <li>자바스크립트에서 모든 객체는 <strong>Object를 기반</strong>으로 만들어진다.</li>
            <li><code>Object</code>는 내장 타입(생성자 함수)이며, 객체를 다룰 수 있는 기본 기능들을 제공한다.</li>
            <li>즉, 객체는 <code>Object</code>의 인스턴스이며, 프로토타입 체인을 통해 Object의 메서드를 상속받는다.</li>
        </ul>
    </section>
    <section>
        <h2>자바스크립트에서 타입 선언하기</h2>

        <h3>1. 생성자 함수(Constructor Function)</h3>
        <pre>
function User(name, age) {
  this.name = name;   // this로 필드(프로퍼티) 정의
  this.age = age;
}
let user = new User("경민", 39);
  </pre>
        <ul>
            <li>생성자 함수는 관례적으로 <strong>이름을 대문자</strong>로 시작한다</li>
            <li><code>this</code>를 사용해 인스턴스의 속성(필드)을 정의한다</li>
            <li><code>new</code> 키워드를 사용하면 새로운 객체가 자동으로 생성되어 <code>this</code>에 바인딩된다</li>
        </ul>

        <h3>2. 클래스(Class, ES6 이후)</h3>
        <pre>
class User {
  constructor(name, age) {
    this.name = name;   // this로 필드 정의
    this.age = age;
  }
}
let user = new User("경민", 39);
  </pre>
        <ul>
            <li>클래스 문법은 <strong>생성자 함수를 더 직관적으로 표현한 문법적 설탕(Syntactic Sugar)</strong>이다</li>
            <li>내부적으로는 생성자 함수와 거의 동일하게 동작한다</li>
            <li><code>constructor</code> 메서드 안에서 초기화를 진행한다</li>
            <li>프로토타입 기반 객체지향 모델을 더 쉽게 작성할 수 있도록 제공된 문법이다</li>
        </ul>
    </section>
    <section>
        <h2>Object의 주요 유용한 메서드</h2>
        <ul>
            <li><code>Object.keys(obj)</code> : 객체의 키 목록을 배열로 반환</li>
            <li><code>Object.values(obj)</code> : 객체의 값 목록을 배열로 반환</li>
            <li><code>Object.entries(obj)</code> : 키-값 쌍을 배열 형태로 반환</li>
            <li><code>Object.assign(target, source)</code> : 객체 복사 또는 합치기</li>
            <li><code>Object.freeze(obj)</code> : 객체를 동결(값 수정/추가/삭제 불가)</li>
            <li><code>Object.seal(obj)</code> : 프로퍼티 추가/삭제 불가, 기존 값 수정은 가능</li>
            <li><code>Object.create(proto)</code> : 지정한 프로토타입을 가진 새 객체 생성</li>
            <li><code>Object.hasOwn(obj, key)</code> : 키가 객체에 직접 존재하는지 확인</li>
        </ul>
    </section>
    <section>
        <h2>기본형 vs 객체 차이</h2>
        <h3>1. 저장 방식</h3>
        <ul>
            <li><strong>기본형(Primitive)</strong>: 데이터 자체가 곧 값이다.
                메모리에 저장될 때 <em>값 그 자체</em>가 기록된다. (예: 숫자 10 → 2진수 1010...이 메모리에 직접 저장)</li>
            <li><strong>객체(Object, 참조형)</strong>: 자료형 자체가 값을 직접 저장하지 않는다.
                대신 <em>값이 저장된 위치(참조 구조)</em>를 메모리에 기록하고, 실제 값은 힙(Heap) 메모리에 별도로 저장된다.</li>
            <li>즉, 기본형은 “값 중심 저장”, 객체는 “참조 구조를 통한 간접 저장” 방식이다.</li>
        </ul>
        <h3>2. 불변성</h3>
        <ul>
            <li><strong>기본형(Primitive)</strong>: 한 번 만들어진 값은 절대 바뀌지 않는다.
                예를 들어 문자열 "hello"는 생성된 뒤 내부 문자를 바꿀 수 없으며,
                다른 문자열을 만들 때는 새로운 값이 생성된다.</li>
            <li><strong>객체(Object)</strong>: 객체는 가변적이다.
                같은 객체 안의 프로퍼티 값은 자유롭게 수정·삭제·추가할 수 있다.</li>
        </ul>
        <h3>3. 비교 방식</h3>
        <ul>
            <li>기본형: 값이 같으면 ==, === 모두 true</li>
            <li>객체: 서로 다른 객체는 내용이 같아도 false (참조 비교)</li>
            <li>예:
                <pre>
let a = {x:1};
let b = {x:1};
console.log(a === b); // false (내용 같아도 참조 다름)
      </pre>
            </li>
        </ul>
        <h3>메모리 구조</h3>
        <ul>
            <li><strong>스택(Stack) 메모리</strong>
                <ul>
                    <li>함수 호출 시 지역 변수, 매개변수, 기본형(Primitive) 값 등이 저장됨</li>
                    <li>속도가 빠르지만 저장 공간이 한정적</li>
                </ul>
            </li>
            <li><strong>힙(Heap) 메모리</strong>
                <ul>
                    <li>객체(Object), 배열(Array), 함수(Function) 등이 저장됨</li>
                    <li>가비지 컬렉터(GC)가 사용하지 않는 데이터를 정리</li>
                </ul>
            </li>
        </ul>
    </section>
    <section>
        <h2>배열과 객체의 차이</h2>
        <h3>1. 키의 형태</h3>
        <ul>
            <li>객체: 키가 문자열(또는 심볼)</li>
            <li>배열: 키가 0부터 시작하는 정수형 인덱스</li>
        </ul>

        <h3>2. 순서</h3>
        <ul>
            <li>객체: 프로퍼티에 순서가 보장되지 않음</li>
            <li>배열: 인덱스를 기준으로 <strong>순서가 보장</strong>됨</li>
        </ul>

        <h3>3. length 속성</h3>
        <ul>
            <li>객체: length 없음</li>
            <li>배열: length 자동 관리 (가장 큰 인덱스 + 1)</li>
        </ul>
        <h3>4. 저장 구조</h3>
        <ul>
            <li><strong>객체(Object)</strong>: 키(Key)-값(Value) 쌍으로 저장.
                키는 문자열이나 심볼이고, 프로퍼티 순서가 보장되지 않는다.</li>
            <li><strong>배열(Array)</strong>: 값(Value)들이 <strong>인덱스(0부터 시작)</strong>를 따라
                순서대로 저장된다.
                내부적으로 엔진이 연속된 메모리 블록처럼 관리하여
                순서 기반 탐색과 반복에 최적화되어 있다.</li>
        </ul>
        <h3>예시 비교</h3>
        <pre>
// 객체
let user = {name: "경민", age: 39};
console.log(user.name); // "경민"

// 배열
let arr = ["경민", 39];
console.log(arr[0]); // "경민"
    </pre>
    </section>
</body>
</html>