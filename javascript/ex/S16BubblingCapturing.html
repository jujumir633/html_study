<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>이벤트의 버블링과 캡처링</title>
    <link rel="stylesheet" href="/src/css/study.css">
</head>
<body>
    <h1>이벤트의 버블링과 캡처링</h1>
    <section>
        <h2>이벤트 전파(Event Propagation)</h2>
        <p>DOM 요소는 부모와 자식 관계로 이루어져 있고, 이벤트가 발생하면 이 관계를 따라 전파된다.</p>
        <p>
            이벤트 전파에는 두 가지 흐름이 있다.
            <strong>캡처링(Capturing)</strong>은 최상위 요소(문서)에서 시작하여 자식 요소까지 내려가며 이벤트 대상을 찾는 과정이고,
            <strong>버블링(Bubbling)</strong>은 실제 이벤트가 발생한 대상(타깃)에서 시작하여 다시 부모 요소를 거쳐 위로 올라가는 과정이다.
        </p>
        <p>
            이 두 과정을 합쳐 <strong>이벤트 전파(Event Propagation)</strong>라 부른다.
            기본적으로 브라우저는 버블링 단계를 통해 부모 요소에서도 이벤트를 감지할 수 있게 해준다.
        </p>        <ul>
            <li>브라우저에서 이벤트가 발생하면 DOM 트리를 따라 전파된다.</li>
            <li>전파 단계는 3단계:
                <ul>
                    <li><strong>캡처링 단계(Capturing)</strong> : 문서 최상위에서 시작해 이벤트 대상까지 내려감</li>
                    <li><strong>타깃 단계(Target)</strong> : 실제 이벤트가 발생한 요소</li>
                    <li><strong>버블링 단계(Bubbling)</strong> : 타깃에서 시작해 다시 상위 요소로 올라감</li>
                </ul>
            </li>
            <li>이 과정을 통해 부모 요소가 자식의 이벤트를 감지할 수 있다.</li>
        </ul>
    </section>

    <section>
        <h2>캡처링과 버블링</h2>
        <ul>
            <li>기본 동작은 <strong>버블링</strong> 단계에서만 이벤트를 잡는다.</li>
            <li><code>addEventListener("이벤트", handler, true)</code> → 캡처링 단계에서 실행</li>
            <li><code>addEventListener("이벤트", handler, false)</code> (기본값) → 버블링 단계에서 실행</li>
            <li>즉, 세 번째 매개변수 또는 옵션 객체 <code>{ capture: true }</code>로 제어 가능</li>
        </ul>
    </section>

    <section>
        <h2>예시: 캡처링 vs 버블링</h2>
        <h3>event.target : <span id="targetStr"></span></h3>
        <h3>캡처링,버블링 : <span id="bubbleStr"></span></h3>
        <div id="outer" style="padding:1em; border:2px solid red;">
            OUTER(mouseover)
            <div id="inner" style="padding:1em; border:2px solid blue;">
                INNER
                <div id="target" style="padding:1em; border:2px solid green;">
                    target
                </div>

            </div>
        </div>
        <script>
            const outer = document.getElementById("outer");
            const inner = document.getElementById("inner");
            const target = document.getElementById("target");
            //mouseover : 캡처링과 버블링으로 이벤트 전파를 확인하는 일반적인 마우스 이벤트
            //mouseenter : 캡처링으로 타겟만 찾는 마우스 이벤트, 버블링으로 돌아가지 않는다.
            // 캡처링 핸들러
            outer.addEventListener("mouseover", (e) =>{
                targetStr.innerText=e.target.id;
            }, true);
            outer.addEventListener("mouseover", (e) =>{bubbleStr.innerText=" out 캡처 =>";},true)
            inner.addEventListener("mouseover", (e) =>{bubbleStr.innerText+=" inner 캡처 =>";},true)

            outer.addEventListener("mouseover", (e) =>{bubbleStr.innerText+=" out 버블";})
            inner.addEventListener("mouseover", (e) =>{bubbleStr.innerText+=" inner 버블=>";})

            target.addEventListener("mouseover", (e) =>{
                bubbleStr.innerText+=" [target] =>";
                // e.stopPropagation(); // mouseenter와 동일함
            })


        </script>
        <p>실행 순서: <code>outer capture → inner capture →  [target] → inner bubble → outer bubble</code></p>
    </section>

    <section>
        <h2>이벤트 전파 제어 & 타깃 속성 정리</h2>
        <ul>
            <li><code>event.stopPropagation()</code>
                → 이벤트가 부모(상위)나 자식(하위) 요소로 더 이상 전파되지 않음</li>
            <li><code>event.stopImmediatePropagation()</code>
                → 같은 요소에 걸린 다른 이벤트 핸들러까지 실행되지 않게 막음</li>
            <li><code>event.preventDefault()</code>
                → 전파는 유지되지만, 요소의 기본 동작을 막음 (예: a 태그 링크 이동, form 제출)</li>
            <li><code>event.target</code>
                → 이벤트가 실제 발생한 **가장 안쪽(타깃) 요소**
                (예: &lt;strong&gt; 클릭 시, 부모 &lt;p&gt;가 리스너를 가지고 있더라도 target은 &lt;strong&gt;)</li>
            <li><code>event.currentTarget</code>
                → 현재 이 이벤트를 실행 중인 **리스너가 달린 요소**
                (예: &lt;p&gt;에 리스너를 달면, p 안쪽의 strong을 클릭했어도 currentTarget은 p)</li>
        </ul>
    </section>
    <section>
        <h2>실전 활용</h2>
        <ul>
            <li>대부분은 버블링 단계에서 이벤트를 처리한다 (기본 동작).</li>
            <li>이벤트 위임(Event Delegation): 부모에 핸들러 하나만 등록하고, 자식의 이벤트를 버블링으로 처리 → 성능과 유지보수에 유리.</li>
            <li>캡처링은 잘 쓰이지 않지만, 특정 상황에서 먼저 이벤트를 가로채고 싶을 때 사용한다.</li>
        </ul>
        <style>
            .active{
              border:2px solid red;
            }
        </style>
        <h3>버블링과 캡처링으로 같은 target을 수종할때 발생하는 문제</h3>
        <p> div#ex1>div>(p>strong)*5 : p요소를 클릭하면 .active 추가 </p>
        <p>부모요소와 자식요소가 같은 이벤트 정의시 자식이 이벤트 실행후 부모의 이벤트를 실행함</p>
        <p>부모와 자식이 모두 this.target으로 .active를 toggle로 수정하고 있어서 2번 토글해서 .active가 사라짐 </p>
        <div id="ex1" style="padding: 2em; background: #f9c2c2">
            <div style="background: lightblue;">
                <p><strong>01</strong></p>
                <p><strong>02</strong></p>
                <p><strong>03</strong></p>
                <p><strong>04</strong></p>
                <p><strong>05</strong></p>
            </div>
        </div>
        <script>
            ex1.addEventListener("click", (e) =>{
                e.target.classList.toggle("active");
            });
            for(let p of ex1.querySelectorAll("p")) {
                p.addEventListener("click", (e) => {
                    e.target.classList.toggle("active");
                });

            }
        </script>
        <h3>캡처링과 이벤트 전파를 멈춰서 동작하게 함</h3>
        <p>target의 이벤트 이후 캡처링 전파를 멈춤</p>
        <div id="ex2" style="padding: 2em; background: #f9c2c2">
            <div style="background: lightblue;">
                <p><strong>01</strong></p>
                <p><strong>02</strong></p>
                <p><strong>03</strong></p>
                <p><strong>04</strong></p>
                <p><strong>05</strong></p>
            </div>
        </div>
        <script>
            ex2.addEventListener("click", (e) =>{
                e.target.classList.toggle("active");
            });
            for(let p of ex2.querySelectorAll("p")) {
                p.addEventListener("click", (e) => {
                    e.target.classList.toggle("active");
                    e.stopPropagation();
                });

            }
        </script>
        <h3>캡처링과 이벤트 전파를 멈춰서 동작하게 함</h3>
        <p>currentTarget 으로 이벤트를 정의한 요소만 target으로 지정후 캡처링 전파를 멈춤</p>
        <div id="ex3" style="padding: 2em; background: #f9c2c2">
            <div style="background: lightblue;">
                <p><strong>01</strong></p>
                <p><strong>02</strong></p>
                <p><strong>03</strong></p>
                <p><strong>04</strong></p>
                <p><strong>05</strong></p>
            </div>
        </div>
        <script>
            ex3.addEventListener("click", (e) =>{
                e.currentTarget.classList.toggle("active");
            });
            for(let p of ex3.querySelectorAll("p")) {
                p.addEventListener("click", (e) => {
                    e.currentTarget.classList.toggle("active");
                    e.stopPropagation();
                });
            }
        </script>
    </section>
    <h2>버블링 캡처링 문제</h2>
    <section>
        <h3>문제 1</h3>
        <p>DOM 이벤트 전파 단계 중, 문서 최상위에서 시작해 타깃 요소까지 내려가는 과정을 무엇이라고 하는가?</p>
        <h3>문제 2</h3>
        <p>기본적으로 브라우저는 어떤 전파 단계에서 이벤트를 감지하는가?</p>
        <h3>문제 3</h3>
        <p><code>event.target</code>과 <code>event.currentTarget</code>의 차이를 간단히 설명하라.</p>
        <h3>문제 4</h3>
        <p>이벤트가 더 이상 부모로 전파되지 않도록 막을 때 사용하는 메서드는 무엇인가?</p>
        <h3>문제 5</h3>
        <p>이벤트 위임(Event Delegation)을 사용할 때, 부모 요소에 이벤트 핸들러를 달아도 자식 요소의 이벤트를 처리할 수 있는 이유는 무엇인가?</p>
    </section>
    <h2>버블링 캡처링 문제 정답</h2>
    <section>
        <h3>문제 1 정답</h3>
        <p>캡처링(Capturing)</p>
        <h3>문제 2 정답</h3>
        <p>버블링(Bubbling)</p>
        <h3>문제 3 정답</h3>
        <p><code>event.target</code>은 실제 이벤트가 발생한 가장 안쪽 요소,
            <code>event.currentTarget</code>은 이벤트 리스너가 달린 요소</p>
        <h3>문제 4 정답</h3>
        <p><code>event.stopPropagation()</code></p>
        <h3>문제 5 정답</h3>
        <p>이벤트 버블링 덕분에 부모 요소에서 자식 요소의 이벤트를 감지할 수 있기 때문 (이벤트 위임)</p>
    </section>
</body>
</html>