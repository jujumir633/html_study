<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Promise 기반 비동기 통신 API</title>
    <link rel="stylesheet" href="/src/css/study.css">
</head>
<body>
<h1>Promise 기반 비동기 통신 API</h1>
<section>
    <h2>fetch란?</h2>
    <ul>
        <li>브라우저에서 제공하는 네트워크 요청 함수</li>
        <li>Promise 기반 API → 비동기 통신을 간단하게 처리 가능</li>
        <li>기본적으로 <code>GET</code> 요청을 보낸다</li>
    </ul>
</section>

<section>
    <h2>기본 사용법</h2>
    <pre><code>fetch("https://api.example.com/data")
  .then(response => {
    console.log(response); // 응답 객체(Response)
  });</code></pre>
</section>

<section>
    <h2>JSON 응답 처리</h2>
    <ul>
        <li><code>response.json()</code>은 또 다른 Promise를 반환한다</li>
        <li>따라서 <code>then</code>을 한 번 더 써야 한다</li>
    </ul>
    <pre><code>fetch("https://api.example.com/data")
  .then(response => response.json())
  .then(data => {
    console.log("JSON 데이터:", data);
  });</code></pre>
</section>
<section>
    <h2>응답 처리 메서드 종류</h2>
    <ul>
        <li><code>response.json()</code>
            응답 본문을 JSON으로 파싱하여 객체/배열로 반환. Promise를 반환한다.
        </li>
        <li><code>response.text()</code>
            응답 본문을 일반 텍스트(String)로 반환. Promise를 반환한다.
        </li>
        <li><code>response.blob()</code>
            응답 본문을 Blob(Binary Large Object)으로 반환. 이미지, 파일 다운로드 등에 사용. Promise를 반환한다.
        </li>
        <li><code>response.arrayBuffer()</code>
            응답 본문을 저수준 이진 데이터(ArrayBuffer)로 반환. WebGL, 오디오, 영상 처리 등에 활용. Promise를 반환한다.
        </li>
        <li><code>response.formData()</code>
            응답 본문을 FormData 객체로 반환. <code>multipart/form-data</code> 응답 처리에 사용. Promise를 반환한다.
            FormData는 키-값 쌍으로 데이터를 관리하며, 보통 파일 업로드나 폼 전송 시 활용된다.
        </li>
    </ul>
    <pre><code class="language-js">
// JSON 응답
fetch("/data.json")
  .then(res => res.json())
  .then(data => console.log("JSON:", data));

// 텍스트 응답
fetch("/data.txt")
  .then(res => res.text())
  .then(text => console.log("TEXT:", text));

// Blob 응답
fetch("/image.png")
  .then(res => res.blob())
  .then(blob => console.log("BLOB:", blob));

// ArrayBuffer 응답
fetch("/sound.mp3")
  .then(res => res.arrayBuffer())
  .then(buffer => console.log("ARRAYBUFFER:", buffer));

// FormData 응답
fetch("/formdata")
  .then(res => res.formData())
  .then(form => {
    for (const [key, value] of form.entries()) {
      console.log(key, value);
    }
  });
  </code></pre>
</section>
<section>
    <h2>에러 처리</h2>
    <ul>
        <li><code>fetch</code> 자체는 네트워크 에러(서버 접속 불가 등)에서만 reject된다</li>
        <li>HTTP 오류(404, 500 등)는 <code>reject</code>가 아니고 <code>response.ok</code>가 false로 반환된다</li>
        <li>따라서 직접 상태 코드를 확인하고 예외로 처리해야 한다</li>
    </ul>
    <pre><code>fetch("https://api.example.com/data")
  .then(response => {
    if (!response.ok) {
      throw new Error("HTTP 오류: " + response.status);
    }
    return response.json();
  })
  .then(data => {
    console.log("성공:", data);
  })
  .catch(err => {
    console.error("실패:", err.message);
  });</code></pre>
</section>
<section>
    <h2>GET과 POST 요청 방식의 차이</h2>
    <ul>
        <li><strong>GET 방식</strong>
            <ul>
                <li>데이터를 <code>URL</code>의 쿼리스트링(?key=value)으로 전달한다.</li>
                <li>URL에 데이터가 노출되므로 보안에 취약하다.</li>
                <li>캐싱이 가능해 동일 요청 시 서버 부하가 줄 수 있다.</li>
                <li>브라우저 주소창에서 직접 테스트 가능하다.</li>
                <li>주로 <strong>조회(Read)</strong> 요청에 사용한다.</li>
            </ul>
        </li>
        <li><strong>POST 방식</strong>
            <ul>
                <li>데이터를 <code>HTTP 메시지 body</code>에 담아 전송한다.</li>
                <li>URL에 데이터가 보이지 않아 GET보다 상대적으로 안전하다.</li>
                <li>캐싱이 기본적으로 되지 않는다.</li>
                <li>대량의 데이터, 파일 업로드 등 전송에 적합하다.</li>
                <li>주로 <strong>등록(Create), 수정(Update), 삭제(Delete)</strong> 같은 변경 작업에 사용한다.</li>
            </ul>
        </li>
        <li><strong>공통점</strong>
            <ul>
                <li>둘 다 HTTP 프로토콜의 요청 방식(Method)이다.</li>
                <li>요청 시 헤더, 파라미터, 본문 등을 통해 추가 정보를 전달할 수 있다.</li>
            </ul>
        </li>
    </ul>
</section>
<section>
    <h2>POST 요청 방식 비교</h2>
    <ul>
        <li><strong>JSON 전송</strong>
            서버가 <code>application/json</code> 형식을 받을 때 사용한다.
            <code>body</code>에 <code>JSON.stringify()</code> 결과를 넣고, 헤더에 <code>Content-Type: application/json</code>을 지정한다.
        </li>
        <li><strong>FormData 전송</strong>
            서버가 <code>multipart/form-data</code> 형식을 받을 때 사용한다.
            파일 업로드나 일반적인 HTML 폼 데이터를 보낼 때 주로 활용된다.
            <code>headers</code>는 자동으로 설정되므로 <strong>명시하지 않아야</strong> 한다.
        </li>
    </ul>
    <pre><code class="language-js">
// JSON 전송 방식
fetch("https://api.example.com/data", {
  method: "POST",
  headers: {
    "Content-Type": "application/json"
  },
  body: JSON.stringify({ name: "홍길동", age: 20 })
})
.then(res => res.json())
.then(data => console.log("서버 응답(JSON):", data));

// FormData 전송 방식
//기존의 폼데이터를 가져올때
//const form = document.forms['myForm'];
//const formData = new FormData(form); // form 내부의 모든 name/value와 파일을 포함

//새로운 폼데이터를 생성할때
const formData = new FormData();
formData.append("name", "홍길동");
formData.append("age", 20);

fetch("https://api.example.com/data", {
  method: "POST",
  body: formData // headers는 자동 설정
})
.then(res => res.json())
.then(data => console.log("서버 응답(FormData):", data));
  </code></pre>
</section>
</body>
</html>