<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>수가 저장되는 방식과 실수 데이터</title>
    <link rel="stylesheet" href="/src/css/study.css">
</head>
<body>
<h1>수가 저장되는 방식과 실수 데이터</h1>
<h2>수와 데이터</h2>
<section>
    <h3>비트와 바이트</h3>
    <ul>
        <li>비트(bit): 컴퓨터가 다루는 가장 작은 단위 (0 또는 1)</li>
        <li>바이트(byte): 8비트 = 1바이트</li>
        <li>하나의 문자를 표현하거나 작은 정수를 저장할 수 있는 기본 단위</li>
        <li>예: 1바이트 = 8비트 = 10110110</li>
    </ul>
</section>
<section>
    <h3>비트를 사용하는 이유</h3>
    <ul>
        <li>컴퓨터는 전기 신호로 동작 → ON(1), OFF(0) 두 가지 상태만 안정적으로 구분 가능</li>
        <li>0과 1 두 가지 상태로 모든 데이터를 표현할 수 있음</li>
        <li>따라서 가장 작은 정보 단위 = 비트(bit, binary digit)</li>
    </ul>
</section>

<section>
    <h3>바이트가 만들어진 이유</h3>
    <ul>
        <li>비트만으로는 너무 작아 사람이 다루기 불편</li>
        <li>초기 컴퓨터는 문자(알파벳, 숫자, 기호) 저장 필요</li>
        <li>ASCII 코드(128문자)를 저장하려면 최소 7비트 필요</li>
        <li>여유를 두어 8비트를 1바이트로 정의 → 문자 1개 저장 가능</li>
    </ul>
</section>

<section>
    <h3>비트와 바이트의 역할</h3>
    <ul>
        <li>비트: 컴퓨터가 데이터를 표현하는 가장 작은 단위</li>
        <li>바이트: 사람이 다루기 좋은 기본 단위 (문자, 작은 정수)</li>
        <li>확장 단위: 1KB = 1024바이트, 1MB, 1GB 등으로 확장</li>
    </ul>
</section>
<section>
    <h3>정수 저장 방식</h3>
    <ul>
        <li>1바이트(8비트) → 2^8 = 256가지 상태 표현 가능</li>
        <li>부호 없는 정수(unsigned): 0 ~ 255</li>
        <li>부호 있는 정수(signed, 2의 보수): -128 ~ 127</li>
        <li>예: 00000000 → 0  </li>
        <li>예: 11111111 → -1 (-0 으로 하면 수가 남비되어 -1)</li>
        <li>예: 00000011 → 3  </li>
        <li>예: 11111100 → -4 </li>
    </ul>
</section>

<section>
    <h3>실수가 필요한 이유</h3>
    <ul>
        <li>정수만으로는 소수점 표현 불가</li>
        <li>과학, 공학, 그래픽 등 다양한 분야에서 소수 표현 필수</li>
        <li>부동소수점(Floating Point) 방식으로 저장</li>
    </ul>
</section>

<section>
    <h3>부동소수점 저장 구조 (IEEE 754)</h3>
    <ul>
        <li>실수를 ±1.xxxxx × 2^지수 꼴로 정규화</li>
        <li>64비트(Double) 구조
            <ul>
                <li>부호(Sign): 1비트</li>
                <li>지수(Exponent): 11비트</li>
                <li>가수(Mantissa): 52비트</li>
            </ul>
        </li>
        <li>예: 13.625 → 1101.101₂ → 1.101101 × 2^3</li>
    </ul>
</section>

<section>
    <h3>10진 소수의 2진 변환</h3>
    <ul>
        <li>정수부: 2로 나누며 나머지 기록</li>
        <li>소수부: 2를 곱하며 정수부 기록</li>
        <li>2의 거듭제곱 분수는 2진수로 딱 떨어진다</li>
        <li>예: 0.5 = 1/2 = 2⁻¹ = 0.1₂</li>
        <li>예: 0.25 = 1/4 = 2⁻² = 0.01₂</li>
        <li>예: 0.125 = 1/8 = 2⁻³ = 0.001₂</li>
        <li>예: 0.0625 = 1/16 = 2⁻⁴ = 0.0001₂</li>
        <li>예: 0.03125 = 1/32 = 2⁻⁵ = 0.00001₂</li>
        <li>예: 0.1= 0.0625 + 0.03125 + n=0.09375+n=0.00011001100110011₂ ...</li>
    </ul>
</section>
<section>
    <h3>변환 시 발생하는 문제</h3>
    <ul>
        <li>0.1, 0.2 등은 2진수로 무한 반복</li>
        <li>IEEE 754는 52비트까지만 저장 → 근사치</li>
        <li>0.1은 실제로 0.10000000000000000555… 로 저장</li>
        <li>연산 시 오차 발생: 0.1 + 0.2 === 0.3 → false (0.30000000000000004 )</li>
    </ul>
</section>
<section>
    <h3>요약</h3>
    <ul>
        <li>비트/바이트는 데이터 저장의 기본</li>
        <li>정수는 정확히 저장 가능</li>
        <li>실수는 부동소수점 방식으로 저장</li>
        <li>10진 소수는 2진 변환 시 무한소수가 되어 근사값으로 저장</li>
        <li>결과적으로 연산에서 작은 오차 발생 가능</li>
    </ul>
</section>
<h2>문제</h2>
<section>
    <h3>정수 데이터 문제</h3>
    <ul>
        <!-- 정수 관련 -->
        <li>8비트 2진수 <code>00001010</code> 을 부호 없는 정수로 읽으면 몇일까?</li>
        <li>8비트 2진수 <code>11111111</code> 을 부호 없는 정수로 읽으면 몇일까?</li>
        <li>8비트 2진수 <code>11111111</code> 을 부호 있는 정수(2의 보수)로 읽으면 몇일까?</li>
        <li>8비트 2진수 <code>11111100</code> 을 부호 있는 정수(2의 보수)로 읽으면 몇일까?</li>
        <li>10진수 <code>13</code> 을 2진수로 바꾸면 무엇일까?</li>
        <li>10진수 <code>3</code> 을 8비트 2진수로 표현하면 무엇일까?</li>
        <li>10진수 <code>-4</code> 를 8비트 2의 보수로 표현하면 무엇일까?</li>
        <li>10진수 <code>-1</code> 을 8비트 2의 보수로 표현하면 무엇일까?</li>
        <li>8비트 2진수 <code>00000000</code> 은 어떤 정수를 나타낼까?</li>
        <li>8비트 2진수 <code>01111111</code> 은 부호 있는 정수로 몇일까?</li>
    </ul>
    <h3>실수 데이터 문제</h3>
    <ul>
        <li>10진수 <code>0.5</code> 를 2진수로 바꾸면 무엇일까?</li>
        <li>10진수 <code>0.25</code> 를 2진수로 바꾸면 무엇일까?</li>
        <li>10진수 <code>0.75</code> 를 2진수로 바꾸면 무엇일까?</li>
        <li>10진수 <code>0.625</code> 를 2진수로 바꾸면 무엇일까?</li>
        <li>10진수 <code>0.1</code> 은 2진수로 정확히 표현될까? (O / X)</li>
        <li><code>0.1 + 0.2</code> 의 실제 계산 결과는 <code>0.3</code>일까, 아니면 <code>0.30000000000000004</code>일까?</li>
        <li>자바스크립트에서 <code>0.1 + 0.2 === 0.3</code> 의 결과는 true일까 false일까?</li>
        <li>0.1(10) 을 2진수로 바꾸면 앞부분 몇 자리까지 어떻게 나올까? (6자리까지만 쓰기)</li>
        <li>0.2(10) 을 2진수로 바꾸면 어떤 패턴이 반복될까? (앞부분만 쓰기)</li>
        <li>실수를 2진수로 저장할 때 오차가 생기는 이유는 무엇일까? (①무한 반복되는 소수를 잘라내서 / ②계산을 잘못해서)</li>
    </ul>
</section>

<h2>정답</h2>
<section>
    <h3>정수문제 정답</h3>
    <ul>
        <!-- 정수 정답 -->
        <li><code>00001010</code> = 10 (unsigned)</li>
        <li><code>11111111</code> = 255 (unsigned)</li>
        <li><code>11111111</code> = -1 (signed, 2의 보수)</li>
        <li><code>11111100</code> = -4 (signed, 2의 보수)</li>
        <li>13 = <code>1101</code></li>
        <li>3 = <code>00000011</code></li>
        <li>-4 = <code>11111100</code></li>
        <li>-1 = <code>11111111</code></li>
        <li><code>00000000</code> = 0</li>
        <li><code>01111111</code> = 127 (signed max)</li>
    </ul>
    <h3>실수 문제 정답</h3>
    <ul>
        <li>0.5 = <code>0.1₂</code></li>
        <li>0.25 = <code>0.01₂</code></li>
        <li>0.75 = <code>0.11₂</code></li>
        <li>0.625 = <code>0.101₂</code></li>
        <li>정답: X (0.1은 2진수로 무한 반복)</li>
        <li>정답: <code>0.30000000000000004</code></li>
        <li>정답: false</li>
        <li>정답: <code>0.000110</code> … (0011 패턴 반복 시작)</li>
        <li>정답: <code>0.0011…</code> (0011 반복)</li>
        <li>정답: ① 무한 반복되는 소수를 잘라내서</li>
    </ul>

</section>
</body>
</html>