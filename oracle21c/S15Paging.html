<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>오라클의 페이징</title>
    <link rel="stylesheet" href="/src/css/study.css">

</head>
<body>
    <h1>오라클의 페이징</h1>
    <section>
        <h2>페이징(Paging) 개념</h2>
        <ul>
            <li>데이터를 한 번에 전부 가져오지 않고 일정 단위(페이지)로 나누어 조회하는 방식</li>
            <li>예: 게시판에서 1페이지당 5건씩 출력</li>
            <li>핵심: "몇 번째 행부터 몇 개를 가져올지"를 결정 (Offset / Limit)</li>
        </ul>
    </section>

    <section>
        <h2>1. ROWNUM 이용 (전통 방식)</h2>
        <ul>
            <li>오라클에서 모든 버전에서 사용 가능</li>
            <li><code>ROWNUM</code>은 결과 집합에 순서대로 붙는 임시 행 번호</li>
            <li>정렬이 있을 경우, 반드시 인라인 뷰로 정렬을 먼저 확정해야 함</li>
        </ul>

        <h3>정렬 없는 경우</h3>
        <pre><code>-- 페이지당 5건, 2페이지(=6~10행) 조회
SELECT *
FROM (
  SELECT ROWNUM AS rnum, e.*
  FROM emp e
  WHERE ROWNUM &lt;= 10
)
WHERE rnum &gt; 5;
</code></pre>

        <h3>정렬 있는 경우</h3>
        <pre><code>-- 급여 내림차순 정렬 후 2페이지(=6~10행) 조회
SELECT *
FROM (
  SELECT ROWNUM AS rnum, x.*
  FROM (
    SELECT e.*
    FROM emp e
    ORDER BY sal DESC    -- ① 정렬 확정
  ) x
  WHERE ROWNUM &lt;= 10     -- ② 상한 적용
)
WHERE rnum &gt; 5; -- ③ 원하는 구간 추출
</code></pre>
    </section>
    <section>
        <h2>ROWNUM 페이징에서 내부 제한을 두는 이유</h2>
        <pre><code>--권장
SELECT *
FROM (
    SELECT em.*, ROWNUM rnum
    FROM (
        SELECT * FROM emp ORDER BY SAL
    ) em
    WHERE ROWNUM &lt;= 10   -- Top-N/STOPKEY 최적화
)
WHERE rnum &gt; 5;          -- 페이지 시작점

--권장하지 않음 데이터가 많이지면 느려짐
SELECT *
FROM (
    SELECT em.*, ROWNUM rnum
    FROM (
        SELECT * FROM emp ORDER BY SAL
    ) em
)
WHERE rnum BETWEEN 5 AND 10;          -- 페이지 시작점

            </code></pre>
        <ul>
            <li>SELECT 의 ROWNUM과 WHERE의 ROWNUM은 동시에 동작합니다. ROWNUM으로 번호를 출력하는동안 WHERE의 ROWNUM 도 번호를 출력하며 출력된 번호를
            접근해서 복잡한 동작을 정의할 수 없습니다. 하지만 일정크기 이상일때 멈추가할 수 있습니다.</li>
            <li><code>ROWNUM</code>은 <strong>ORDER BY보다 먼저</strong> 붙기 때문에 단순히 <code>BETWEEN</code>만 쓰면 전체 결과에 번호를 매긴 뒤 잘라내 비효율적입니다.</li>
            <li>안쪽 서브쿼리에서 <code>ROWNUM &lt;= N</code>을 먼저 걸면 오라클 옵티마이저가 <strong>Top-N/STOPKEY 최적화</strong>를 적용해 필요한 개수까지만 읽고 멈춰 성능이 좋아집니다.</li>
            <li>따라서 보통 “<code>ROWNUM &lt;= 최대행</code> → 바깥에서 <code>rnum &gt; 시작행</code>” 패턴을 사용해 페이징을 구현합니다.</li>
            <li>12c 이상이라면 <code>OFFSET … FETCH</code> 구문을 쓰면 같은 효과를 표준 SQL 문법으로 간단히 낼 수 있습니다.</li>
        </ul>
    </section>

    <section>
        <h2>2. ROW_NUMBER() 분석 함수 이용</h2>
        <ul>
            <li>오라클 9i 이상부터 지원</li>
            <li><code>ROW_NUMBER()</code> 함수는 지정한 정렬 기준에 따라 순번을 부여</li>
            <li>정렬이 필요한 경우 ROWNUM보다 직관적이고 실무에서 가장 많이 사용됨</li>
        </ul>

        <pre><code>-- 급여 높은 순으로 2페이지(=6~10행) 조회
SELECT *
FROM (
  SELECT e.*, ROW_NUMBER() OVER (ORDER BY sal DESC) AS rnum
  FROM emp e
)
WHERE rnum BETWEEN 6 AND 10;
</code></pre>
    </section>

    <section>
        <h2>3. OFFSET / FETCH 구문 (Oracle 12c 이상)</h2>
        <ul>
            <li>SQL 표준 방식으로, 가장 직관적이고 간단한 페이징 방법</li>
            <li><code>OFFSET n ROWS</code> : 앞의 n개 행을 건너뜀</li>
            <li><code>FETCH NEXT m ROWS ONLY</code> : 그 다음 m개 행을 가져옴</li>
        </ul>

        <pre><code>-- 급여 높은 순으로 2페이지(=6~10행) 조회
SELECT ename, sal
FROM emp
ORDER BY sal DESC
OFFSET 5 ROWS FETCH NEXT 5 ROWS ONLY;
</code></pre>
    </section>

    <section>
        <h2>방식 비교</h2>
        <ul>
            <li><strong>ROWNUM</strong>: 모든 버전에서 사용 가능, ORDER BY 시 주의 필요</li>
            <li><strong>ROW_NUMBER()</strong>: 9i 이상, 정렬 기준 명확, 실무 표준</li>
            <li><strong>OFFSET / FETCH</strong>: 12c 이상, SQL 표준, 가장 직관적</li>
        </ul>
    </section>
    <section>
        <h2>MySQL 페이징 기본</h2>
        <ul>
            <li>MySQL에서는 <code>LIMIT</code>으로 페이징을 처리한다</li>
            <li>형식: <code>LIMIT 시작위치, 개수</code> (시작은 0부터)</li>
            <li><code>LIMIT 개수 OFFSET 시작위치</code> 형태도 가능하다</li>
        </ul>
    </section>

    <section>
        <h2>예시</h2>
        <pre><code>-- 1페이지 (1~5행)
SELECT * FROM emp
ORDER BY sal DESC
LIMIT 0, 5;

-- 2페이지 (6~10행)
SELECT * FROM emp
ORDER BY sal DESC
LIMIT 5, 5;

-- 3페이지 (11~15행)
SELECT * FROM emp
ORDER BY sal DESC
LIMIT 10, 5;

-- OFFSET 문법
SELECT * FROM emp
ORDER BY sal DESC
LIMIT 5 OFFSET 5;
</code></pre>
    </section>

    <section>
        <h2>pay_history 페이징 연습문제</h2>
        <p><em>테이블 구조: PAY_ID, EMPNO, PAY_DATE, AMOUNT, BONUS</em></p>
    </section>

    <section>
        <h3>① ROWNUM 방식</h3>
        <ol>
            <li><code>pay_history</code> 를 정렬 없이 1페이지(1~5행)를 조회하라. (페이지당 5건)
                <small>힌트: 안쪽에서 <code>ROWNUM &lt;= 5</code>, 바깥에서 <code>rnum &gt;= 1 </code></small></li>
            <li>정렬 없이 2페이지(6~10행)를 조회하라. (페이지당 5건)</li>
            <li>10번 부서의 <code>pay_history</code>를 1페이지(1~5행) 조회하라.</li>
        </ol>
    </section>

    <section>
        <h3>② ROW_NUMBER() 함수 방식</h3>
        <ol start="4">
            <li><code>pay_history</code>에서 급여일(<code>PAY_DATE</code>) 내림차순으로 정렬 후, 1페이지(1~5행)를 조회하라.
                <small>힌트: <code>ROW_NUMBER() OVER (ORDER BY PAY_DATE DESC)</code></small></li>
            <li><code>pay_history</code>에서 금액(<code>AMOUNT</code>) 높은 순으로 2페이지(6~10행)를 조회하라.</li>
            <li><code>pay_history</code>에서 보너스(<code>BONUS</code>)가 있는 건만 대상으로 <code>PAY_DATE DESC</code> 정렬 후 1페이지(1~5행)를 조회하라.</li>
        </ol>
    </section>

    <section>
        <h3>③ OFFSET / FETCH 방식 (Oracle 12c+ 또는 MySQL)</h3>
        <ol start="7">
            <li><code>pay_history</code>에서 <code>PAY_DATE DESC</code> 기준으로 1페이지(1~5행)를 조회하라.
                <small>힌트: <code>OFFSET 0 ROWS FETCH NEXT 5 ROWS ONLY</code></small></li>
            <li><code>pay_history</code>에서 <code>AMOUNT DESC</code> 기준으로 2페이지(6~10행)를 조회하라.</li>
            <li><code>pay_history</code>에서 직책(JOB)이 <code>SALESMAN</code>인 사원의 데이터를 <code>PAY_DATE DESC</code> 정렬 후 2페이지(6~10행)를 조회하라.</li>
            <li><code>pay_history</code>최근 30일 이내 데이터만 대상으로 <code>PAY_DATE DESC</code> 정렬 후 1페이지(1~5행)를 조회하라.</li>
        </ol>
    </section>
    <section>
        <h2>pay_history 페이징 정답</h2>
        <ol>
            <li>
      <pre><code>SELECT *
FROM (
  SELECT ROWNUM AS rnum, ph.*
  FROM pay_history ph
  WHERE ROWNUM &lt;= 5
)
WHERE rnum &gt;= 1;</code></pre>
            </li>
            <li>
      <pre><code>SELECT *
FROM (
  SELECT ROWNUM AS rnum, ph.*
  FROM pay_history ph
  WHERE ROWNUM &lt;= 10
)
WHERE rnum BETWEEN 6 AND 10;</code></pre>
            </li>
            <li>
      <pre><code>SELECT *
FROM (
  SELECT ROWNUM AS rnum, x.*
  FROM (
    SELECT ph.*
    FROM pay_history ph
    JOIN emp e ON e.empno = ph.empno
    WHERE e.deptno = 10
  ) x
  WHERE ROWNUM &lt;= 5
)
WHERE rnum &gt;= 1;</code></pre>
            </li>
            <li>
      <pre><code>SELECT *
FROM (
  SELECT ph.*, ROW_NUMBER() OVER (ORDER BY ph.pay_date DESC) AS rn
  FROM pay_history ph
)
WHERE rn BETWEEN 1 AND 5;</code></pre>
            </li>
            <li>
      <pre><code>SELECT *
FROM (
  SELECT ph.*, ROW_NUMBER() OVER (ORDER BY ph.amount DESC) AS rn
  FROM pay_history ph
)
WHERE rn BETWEEN 6 AND 10;</code></pre>
            </li>
            <li>
      <pre><code>SELECT *
FROM (
  SELECT ph.*, ROW_NUMBER() OVER (ORDER BY ph.pay_date DESC) AS rn
  FROM pay_history ph
  WHERE ph.bonus IS NOT NULL
)
WHERE rn BETWEEN 1 AND 5;</code></pre>
            </li>
            <li>
      <pre><code>SELECT *
FROM pay_history
ORDER BY pay_date DESC
OFFSET 0 ROWS FETCH NEXT 5 ROWS ONLY;</code></pre>
            </li>
            <li>
      <pre><code>SELECT *
FROM pay_history
ORDER BY amount DESC
OFFSET 5 ROWS FETCH NEXT 5 ROWS ONLY;</code></pre>
            </li>
            <li>
      <pre><code>SELECT ph.*
FROM pay_history ph
JOIN emp e ON e.empno = ph.empno
WHERE e.job = 'SALESMAN'
ORDER BY ph.pay_date DESC
OFFSET 5 ROWS FETCH NEXT 5 ROWS ONLY; -- 3페이지(11~15행)</code></pre>
            </li>
            <li>
      <pre><code>SELECT *
FROM pay_history
WHERE pay_date &gt;= SYSDATE - 30
ORDER BY pay_date DESC
OFFSET 0 ROWS FETCH NEXT 5 ROWS ONLY;</code></pre>
            </li>
        </ol>
    </section>


</body>
</html>