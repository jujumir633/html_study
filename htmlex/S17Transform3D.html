<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Transform 3D</title>
    <link rel="stylesheet" href="/src/css/study.css">
    <style>

        .container{
            background: rgba(196, 216, 222, 0.5);
            border: 1px solid #2c4851;
            display: flex;
            justify-content: center;
        }
        /* 공통 블록 스타일 */
        .scene {
            perspective: 600px; /* 원근감 거리 */
        }
        .block {
            width: 120px;
            height: 120px;
            background:  #4e9af1;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            border-radius: 8px;
            transition: transform 1s;
            cursor: pointer;
            margin: 3em;
        }
        .grid-container{
            margin: 0 auto;
            width: 25em;
            padding: 2em;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-auto-rows: 5em;
            gap: 2em;
            background-color: rgba(159, 203, 204, 0.42);
            perspective: 15em;

        }
        .grid-container>div{
            display: flex;
            align-items: center;
            justify-content: center;
            background: lightgray;
            transform: translateZ(3em) rotateX(90deg);
            transition: transform 1s;
        }
        .grid-container:hover>div{
            transform: translateZ(-200px) rotateX(90deg)  ;
        }
    </style>
</head>
<body>
    <h1>Transform 3D</h1>
    <section>
        <h2>CSS 3D 트랜스폼: 개념과 좌표</h2>
        <ul>
            <li><strong>3D 좌표축</strong><br>
                x(가로), y(세로), z(깊이) 축을 사용해 요소를 회전/이동/확대합니다. z축은 화면 안(-)·밖(+) 방향입니다.</li>
            <li><strong>렌더링 원리</strong><br>
                화면은 2D 평면이므로 3D 장면을 원근 투영으로 2D에 그립니다. 이때 관찰자와 장면 사이의 거리인 <code>perspective</code>가 필요합니다.</li>
        </ul>
    </section>

    <section>
        <h2>왜 “거리(perspective)”가 필요한가</h2>
        <ul>
            <li><strong>원근감을 만드는 원리</strong><br>
                가까운 물체는 크게, 먼 물체는 작게 보이는데, CSS에서 이 효과를 만들려면 카메라와 무대 사이의 거리를 알려줘야 함. 이 거리가 <code>perspective</code> 값.</li>
            <li><strong>원근감의 변화</strong><br>
                값이 작을수록(300~600px) → 가까이서 보는 것처럼 원근감이 강하고 왜곡이 큼.<br>
                값이 클수록(1500px 이상) → 멀리서 보는 것처럼 거의 평평하게 보임.</li>
            <li><strong>속성 vs 함수</strong><br>
                <code>perspective: 800px;</code> → 부모에 적용, 자식 전체가 같은 카메라 시점.<br>
                <code>transform: perspective(800px) rotateY(45deg);</code> → 해당 요소 1개에만 적용.</li>
            <li><strong>소실점(perspective-origin)</strong><br>
                원근 방향의 중심점. 기본값은 <code>50% 50%</code>이지만, 왼쪽/오른쪽, 위/아래로 변경 가능.</li>
        </ul>

        <h3> 원근감 없는 블럭</h3>
        <!-- 원근감 없는 블럭 -->
        <div class="container">
            <div class="block" style="transform: rotateY(30deg)">rotateY(30deg)</div>
            <div class="block" style="transform: rotateX(30deg); ">rotateX(30deg)</div>
            <div class="block" style="transform: translateZ(-20em)">translateZ(20em)</div>

        </div>
        <h3>원근감 있는 블럭 (600px)</h3>
        <!-- 원근감 있는 블럭 -->
        <div class="container scene">
            <div class="block" style="transform: rotateY(30deg)">rotateY(30deg)</div>
            <div class="block" style="transform: rotateX(30deg)">rotateX(30deg)</div>
            <div class="block" style="transform: translateZ(-20em)">translateZ(-20em)</div>
        </div>
        <h3>원근감 있는 블럭 (600px) + 부모 자식이 서로 3D로 연관있는 블럭</h3>
        <!-- 원근감 있는 블럭 -->
        <div class="container scene" style="transform-style: preserve-3d;">
            <div class="block" style="transform: rotateY(30deg)">rotateY(30deg)</div>
            <div class="block" style="transform: rotateX(30deg)">rotateX(30deg)</div>
            <div class="block" style="transform: translateZ(-20em)">translateZ(-20em)</div>
        </div>

        <h3>원근감 예시</h3>
        <div class="grid-container scene" style="transform-style: preserve-3d;">
            <div><b>01</b></div>
            <div><b>02</b></div>
            <div><b>03</b></div>
            <div><b>04</b></div>
            <div><b>05</b></div>
            <div><b>06</b></div>
            <div><b>07</b></div>
            <div><b>08</b></div>
            <div><b>09</b></div>
            <div><b>10</b></div>
            <div><b>11</b></div>
            <div><b>12</b></div>
        </div>
    </section>
    <section>
        <div>

        </div>
    </section>
    <section>
        <h2>3D 관련 속성/함수 모음</h2>
        <ul>
            <li><strong>transform</strong><br>
                <code>translate3d(x,y,z)</code>, <code>translateZ(z)</code>, <code>scale3d(sx,sy,sz)</code>, <code>scaleZ(sz)</code>, <code>rotateX(a)</code>, <code>rotateY(a)</code>, <code>rotateZ(a)</code>, <code>rotate3d(x,y,z,a)</code>, <code>matrix3d(...)</code></li>
            <li><strong>transform-origin</strong><br>
                변환의 기준점을 설정합니다. 구문은 <code>x y z</code>이며, <code>x,y</code>는 길이·백분율 가능, <code>z</code>는 <em>길이(px 등)</em>만 허용(백분율 불가). 기본값 <code>50% 50% 0</code>.</li>
            <li><strong>transform-style</strong><br>
                <code>flat</code>(기본): 자식의 3D를 평면 합성. <code>preserve-3d</code>: 자식들의 3D 관계 유지(부모에 설정).</li>
            <li><strong>perspective (속성)</strong><br>
                부모 컨테이너에 설정해 자식 전체에 공통 원근 적용. 예: <code>.scene { perspective: 800px; }</code></li>
            <li><strong>perspective() (함수)</strong><br>
                단일 요소에만 원근 적용. 예: <code>.box { transform: perspective(800px) rotateY(45deg); }</code></li>
            <li><strong>perspective-origin</strong><br>
                원근의 중심점을 이동. 예: <code>perspective-origin: left top;</code></li>
            <li><strong>backface-visibility</strong><br>
                회전으로 뒷면이 보일 때 뒷면을 감출지 결정. 예: <code>backface-visibility: hidden;</code></li>
        </ul>
    </section>


    <section>
        <h2>순서, 합성, 성능 팁</h2>
        <ul>
            <li><strong>변환 순서</strong><br>
                <code>transform</code> 함수는 <em>오른쪽에서 왼쪽</em> 순으로 적용됩니다. <code>translateZ(...) rotateY(...)</code>와 <code>rotateY(...) translateZ(...)</code>는 결과가 다릅니다.</li>
            <li><strong>3D 유지</strong><br>
                부모에 <code>transform-style: preserve-3d</code>가 없으면 자식의 3D 배치가 납작해집니다.</li>
            <li><strong>뒷면 처리</strong><br>
                카드 뒤집기 등에서는 각 면에 <code>backface-visibility: hidden</code>을 꼭 넣으세요.</li>
            <li><strong>성능</strong><br>
                애니메이션은 <code>transform</code>/<code>opacity</code> 위주로, 큰 블러 그림자/과도한 레이어는 지양. 필요한 곳에만 <code>will-change: transform;</code>을 최소 사용.</li>
        </ul>
    </section>

    <section>
        <h2>미니 실습 1: 카드 플립(원근 + 뒷면 숨김)</h2>
        <ul>
            <li><strong>핵심 포인트</strong><br>
                부모에 <code>perspective</code>, 자식 래퍼에 <code>transform-style: preserve-3d</code>, 각 면에 <code>backface-visibility: hidden</code>.</li>
        </ul>
        <ul>
            <li>
                <style>
                    .card-scene{width:240px;height:160px;margin:40px auto;perspective:800px;}
                    .card{width:100%;height:100%;position:relative;transform-style:preserve-3d;transition:transform .8s;}
                    .card:hover{transform:rotateY(180deg);}
                    .face{position:absolute;inset:0;display:grid;place-items:center;border-radius:12px;
                        backface-visibility:hidden;background:#fff;border:1px solid #ddd;}
                    .back{transform:rotateY(180deg); background:#000; color: #fff}
                </style>
                <div class="card-scene">
                    <div class="card">
                        <div class="face front">FRONT</div>
                        <div class="face back">BACK</div>
                    </div>
                </div>
            </li>
        </ul>
    </section>

    <section>
        <h2>미니 실습 2: transform-origin z로 피벗 이동</h2>
        <ul>
            <li><strong>핵심 포인트</strong><br>
                같은 회전이라도 <code>transform-origin</code>의 <code>z</code>로 피벗을 당기면(양수) 더 과장된 회전처럼 보입니다.</li>
        </ul>
        <ul>
            <li>
                <style>
                    .row{display:flex;gap:24px;justify-content:center;margin:40px 0;perspective:900px;}
                    .box{width:160px;height:120px;display:grid;place-items:center;background:#fff;border:1px solid #ddd;
                    transition:transform .6s;}
                    .a{transform-origin:50% 50% 0;}
                    .b{transform-origin:50% 50% 120px;}
                    .row:hover .a{transform:rotateX(45deg);}
                    .row:hover .b{transform:rotateX(45deg);}
                </style>
                <div class="row">
                    <div class="box a">z=0</div>
                    <div class="box b">z=120px</div>
                </div>
            </li>
        </ul>
    </section>

    <section>
        <h2>자주 하는 실수 체크리스트</h2>
        <ul>
            <li><strong>perspective를 자식에 속성으로 줌</strong><br>
                장면 전체 원근은 부모의 <code>perspective</code>로, 단일 요소만이면 <code>perspective()</code> 함수로.</li>
            <li><strong>preserve-3d 누락</strong><br>
                3D 자식이 평면으로 합쳐지면 입체 배치가 사라집니다.</li>
            <li><strong>transform-origin z에 % 사용</strong><br>
                <code>z</code>는 길이만 허용합니다. 백분율은 불가.</li>
            <li><strong>backface-visibility 미설정</strong><br>
                뒤집힌 글자가 거꾸로 보이면 숨김을 적용하세요.</li>
            <li><strong>변환 순서 착각</strong><br>
                함수는 오른쪽→왼쪽으로 적용됩니다.</li>
        </ul>
    </section>
</body>
</html>